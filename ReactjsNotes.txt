1. React -
    It is an Javascript library
    Declarative programming
    It is based on Component Based Architecture
    It is used to create Single Page Application
    *Javascript is a imperative programming i.e we have to tell that DOM needs to be updated after variable
     is updated

    *Whereas React is declarative programming i.e after declaring variable, whenever it is updated, 
     automatically DOM gets re-rendered

2. React Element - 

    React.createElement (type , props , children)
    It returns a React Element object which has some properties
    {
    "type": "h1", // Here type can be a Function also
    "key": null,
    "ref": null,
    "props": {}, // It is passed as argument to the type 
    "_owner": null,
    "_store": {}
    }
    ReactDOM.createRoot()
    It creates a root element which is further used to render the react elements

    ReactDOM.render(ReactDOM Element)

3. JSX & Babel- 

    Babel -  It transforms JSX (i.e HTML like code with Javascript) into React Element behind the scene
    and renders it on page
    It also converts ECMAScript code into backwards compatble version of Javascript that can be run by 
    older version of Javascript
    *type="text/babel" <script type="text/babel" src="index.js"></script> it tell the browser to include
     the babel file which transform html into react element
    * Why two curly brackets are used in React - It represents Javascript written in html

4. Source Maps - 

    Source maps in Javascript are files that provide a mapping between the source code and the code which is actually 
    being executed by the browser or Javascript engine after transpilation/bundling or minification
    
    Babel after bundling or compilation generates source maps along with the resulting code
    It can be configured using the babel.config.json file
    {
    "presets": ["@babel/preset-react"],
    "sourceMaps": true
    }

5. Bundlers - 

   It is a tool used in web development to combine multiple files such as Javascript, CSS , images into a 
   single file for deployment to a web server.
   for example -  Parcel, Webpack, Vite etc
   It bundles all files into single file and serves that file

6. React Component - 
    Whenever the type value of React element becomes a Function , it creates a React Component
    This React Component is converted into React element by babel/parcel

    React component is a function which returns a JSX which is generally a resuable piece of user interface

7. React Events - 
    An event can be applied to html elements only and not on the React component
    We can accept the event as function and then apply it to the html element of the component

8. How React Knows Not to Reinitialize useState ?
    React keeps track of state between renders using a mechanism called hooks state management, which ensures 
    that the state is preserved across renders and not reinitialized.

9. State vs Props - 
     
    States are mutuable i.e changeable whereas props are immutable
    * On Change of props or state component re-renders

10. React Fragments - 
    React functional component returns a single element.
    Using react fragment no new div is created and we can wrap all the html inside it 
    and it considers it as a single element

11. React Children prop - 

    <ReactComponent> whatever passed is children prop for the ReactComponent </ReactComponent>

    Children prop can be a - 
    React element
    HTML
    Function
    React Component

12. How to scope CSS in React -

    CSS is loaded directly when react app is created and if similar classname is encountered 
    CSS is applied to all the elements with similar classnames
    To overcome this CSSFileName.module.css is used

13. UseEffect hook - 

    It is used to perform side rendering
    It is used to monitor states

    useEffect(callbackFunction,dependencyArray)

    useEffect(()=>{
        //code

    ***    return something // This is called Cleaning up code and is executed when component unmounts
    })

    useEffect(()=>{
        const intervalId = setTimeInterval(()=>{
            console.log("Printing")
        },1000)

        //Cleaning up function, when component unmounts , stopping the setTimeInterval

        return ()=>{
            clearTimeInterval(intervalId)
        }
    })

14. React-router-dom - 

    It is a library used for showing routes in react without relaoding the page
    example - 
    1.Setting up routes
            const router = createBrowserRouter([
            {
            path: "/",
            element: <App />,
            errorElement: <div>Error Page</div>,
            // loader:,
            children: [
            {
                path: "/",
                element: <div>Home</div>,
            },
            {
                path: "Contact",
                element: <div>Contact</div>,
            },
            {
                path: "Contact/:contactId",
                element: <div>Contact Id Page</div>,
            },
            {
                path: "Work",
                element: <div>Work</div>,
            },
            ],
            },
            ]);

            <RouterProvider router={router} />

    2.Navigating to Routes - 
        
        Link and NavLink tags are used to navigate to routes without relaoding the page

        NavLink provides isActive, isPending, isTransitioning props for more styling
        * end makes sures that only Contact route is active
            <NavLink
            to="/Contact"
            className={({ isActive, isPending, isTransitioning }) => {
            return isActive ? styles?.active : "";
            }}
            end
                >
            Contact
            </NavLink>
            <NavLink
                to="/Contact/3"
                className={({ isActive, isPending, isTransitioning }) => {
                return isActive ? styles?.active : "";
                }}
            >
                ContactId
            </NavLink>

    3. Outlet - 
        It is used to render child routes

        using useOutletContext() we get the value passed in Outlet
        <Outlet context={"value"}/>
        const data=useOutletContext()

        We can use customHooks to minimize the imports 
        example - 
            import { createContext, useState } from "react";

            export const ThemeContext = createContext();

            export function ThemeProvider({ children }) {
            console.log(children);
            const [isDark, setisDark] = useState(false);
            return (
                <ThemeContext.Provider value={[isDark, setisDark]}>
                {children}
                </ThemeContext.Provider>
            );
            }

15. Controlled Components - 

    *Inputs, textareas, selects fields value attribute in react is not editable w/o onChange, it is because React adds an event
     to it and make it unchangeable

    *React has unidirectional data binding i.e we can only update the state and it will update the DOM
     whereas bi-directional data binding is followed in AngularJs where on changing the variable value, DOM
     automatically gets updated

    Inputs, textareas, selects fields where input is controlled by react states and not by Javascript
     is called controlled component
    
16. UseRef - 
    It doesn't cause re-renders of the DOM
    It is mostly used to access the DOM elements

    const myRef=useRef('defaultValue')
    myRef is an Object which has current value

17. React Portal - 
    It removes the Component from place where it has been called from actual html and places it in the place
    where it has been mentioned in createPortal
    createPortal from ReactDOM

    createPortal(Component,place where we want to render it)
    createPortal(Component,document.getElementById('portal'))
    *Event binding is still there

18. Code splitting & lazy loading - 
    Lazy load means when user goes to that page then only load the content of that page/module is served

    Bundlers by default creates bundle of whole code, even if it is not required by browser or user
    To solve this lazy loading is done i.e load content when required
    Bundlers creates different files in production build and serves them when required
    Once the file is loaded, for next time browser takes the file from browser and doesn't lazy loads its everytime
    * Suspense is always required
    * Lazy loading works onyl for React components
    * For dynamic imports we can use import() with await, example -
        const { default: sum } = await import('./sumFunction');
        
    example -
    import React, { Suspense } from 'react';
    const LazyComponent = React.lazy(() => import('./LazyComponent'));
    const App = () => (
        <Suspense fallback={<div>Loading...</div>}>
            <LazyComponent />
        </Suspense>
    );
 ***crypto.randomUUID()  - is available only for HTTPS i.e secure networks and not for http

19. Class Components - 
    constructor & render methods are used here
    First constructor function gets called and render gets called when there is change in state

    render method returns JSX
    constructor method provides ways to create and set States
    super is used for calling parents constructor function

20. Life Cycle Methods in Class Based Components - 
    React components stages includes - Mounting, Updating, Unmounting

    Mounting ---->
        constructor
        static getDerivedStateFromProps(props,state)
        render
        componentDidMount

    Updating --->
        static getDerivedStateFromProps(props,state)
        shouldComponentUpdate(nextProps,nextState)
        render()
        getSnapshotBeforeUpdate(prevProps, prevState)
        componentDidUpdate(prevProps,PrevState,snapshots)

    Unmounting --->
        componentWillUnmount

21. Virtual Dom, Reconcillation, Diffing Algorithm - 

    *Virtual DOM is a tree like srtructure of actual DOM elements and react compares the changes in DOM element using
    diffing algorithm and then makes changes in the actual dom

    *This whole process of comparison of DOM element using diffing algorithm is called Reconcillation in react

    *Element created using React.createElement is an Virtual DOM Element and element created using document.createElement
    is an normal DOM element

    *React uses virtual DOM to track changes in element

22. Diffrence btw React and ReactDOM ->
    React ->	Core library for building UIs	
    ReactDOM -> DOM-specific rendering

23. Pure component ->

    In react Pure component extends the PureComponent instead of Component class
    It is used to reduce unnecessary renders of UI when parent component renders

    Same can be replicated in functional components using the React.memo

24. React.memo -
    It is used to prevent re-renders of Child component when Parent component re-renders provided Child
    component props do not change
    Similar to PureComponents
    syntax - const ChildComponent=React.memo(functionalComponent)
    
25. useCallback ,useMemo ,useContext -

    useCallback -
        It is used to create to memoized functions 
        syntax const memoizedFunctionName=useCallback(function,[dependencyArray])
        example -
        * Without using React.memo or useCallback will cause Child Component to re-render everytime and it will create 
          new instance of INCREMENT function.

            function Parent() {
                const [count, setCount] = useState(0);

                const increment = () => {
                    setCount((prev) => prev + 1);
                };

                const memoizedIncrement = useCallback(increment, []);
                console.log("Parent Rendered", count);

                return (
                    <>
                    <div className="app">This is App container</div>
                    <div>Count is {count}</div>
                    <ChildComponent increment={memoizedIncrement} />
                    </>
                );
                    }

    useMemo -
        It is used to memoize a value rather than a function and it recalculates the value only when its
        dependency changes
        syntax - const memoizedValue=useMemo(()=>{
            // calculating the value
        },[dependencyArray])
        
    useContext -
        It is used to pass data from Parent to child component without the need of props drilling

26. Custom hooks -

27. Package json (install a package, ~ vs ^, devDependencies, exact package version) -

    * To install a package as devDependency -
        npm install --save-dev prettier
    * By default packages installed are with ^
    * ^(Caret) vs ~(Tilde) -
            "prettier": "^3.4.2" means 
            The caret ^ symbol allows updates to the minor and patch versions but not the major versions
            means allowed updates - 
                3.4.2>= and <4.0.0
                3.4.2, 3.4.3, 3.5.0, 3.9.9 are allowed
            The tilde ~ symbol allows updates to the patch version only but not the major and minor versions
                3.4.2>= and <3.5.0
                3.4.2, 3.4.3, 3.4.9 are allowed
    * To install a particular version of a package -
        npm install packageName@version
        example npm install prettier@3.4.2 
        This is will install prettier as "prettier": "^3.4.2",
    * To install exact version -
        npm install packageName@version --save-exact
        example - npm install prettier@3.4.2 --save-exact
    * To check package versions -
        npm show packageName versions

28. package.json vs package-lock.json -

    package.json contains -
        meta data about the project such as name, author,description, version etc
        It also contains info about devDependencies used in the project

    package-lock.json -
        It is generate automatically by npm on every npm install
        It locks the versions of the packages installed
        example "prettier": "^3.4.2", 
        package-lock.json will contain exact 3.4.2 version and its resolved urls
        It ensures same packages are installed across different systems
        * However if someone manually changes the version of the package and re-installs it package-lock.json 
            will be updated to the mentioned version
        * While udpating using npm update, if new version is available it will update both package.josn and package-lock.json

29. How to add compatible BROWSERSLIST in package.json -

     "browserslist": {
        "production": [
        "> 0.2%",
        "not dead",
        "not op_mini all"
        ],
        "development": [
        "last 1 chrome version",
        "last 1 firefox version",
        "last 1 safari version"
        ]
    }
    *   "last 2 versions": Supports the last two versions of all major browsers.
    *    not dead": Excludes browsers that are officially discontinued or have <0.5% market share.
    *   "> 0.2%": Includes browsers used by more than 0.2% of global users.
    *   "not op_mini all": Excludes Opera Mini because it has limited feature support.



React.createElement
ReactDOM.createRoot
ReactDOM.render  
***some method,sort method ?