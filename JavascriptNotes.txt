Javascript is a dynamically typed single threaded launguage
* In Javascript memory is alloacted during RunTime

1. Data Types

    Fundamental Data Types/ Primitive Data Types ---

    Boolean,String,Number,Symbol,Undefined,null,BigInt
    All Primitive data types are stored in STACK MEMORY i.e copy of variable is created

    Derived Data Types/ Non Primitive Data Types ---

    Arrays,Objects,Functions
    All Derived data types are stored in HEAP MEMORY i.e reference of variable is created

    * valueOf is used to access the values of Primitive Data types values
        example -

            1. let num=10
                console.log(num.valueOf()) // Output - 10
            
            2. Object.prototype.sayHi=function(){
                console.log(` Hi ${this.valueOf()} `)
            }

        ** We cannot directly add prototypes to PRIMITIVE data types, it can be added only to the 
           NON - PRIMITIVE data types
           let username="Minu"

            username.prototype.sayHi=function(){ // ERROR
                console.log(` Hi ${this.valueOf()} `)
            }

            Correct way -

            String.prototype.sayHi=function(){
                console.log(` Hi ${this.valueOf()} `)
            }
            
2. If Else -  it evaluates a condition and if its is true or false performs certain actions.

3. Ternary Operator - it evaluates an expression and returns a value if it is true
    example - console.log(5>10 ? "yes it is greater" : "No its not")

4. Nullish Operator - 

    console.log(5?? "This is the value")

    means if 5 is Undefined or null then its value will be "This is the value" else it would be 5 only

5. let, var, const - 
 
 var - it has global scope , it can be accessed before declaration of the variable and its value will be Undefined,
        it has global scope i.e window object will have the variable created using var

 let -  it has block level scope, it cannot be accessed before declaration, it has SCRIPT scoped
 
 const - it is similar to let but values once assigned cannot be overwritten

    * const Arrays vlaues,Objects can be overwritten

6. typeof - 
    it is used to determine the type of variable

    typeof(Function) - Function
    typeof(Array) - Object
    typeof(Undefined) - Undefined
    typeof(null) - Object
    typeof(Class) - Function

7. Hoisting - 

    Hoisting in javascript is a feature where variables and functions declarations are moved
    to the top of their defining scopes

    * variables declared using var and Function declared using the keyword function are fully hoisted

    * Function expressions are only partially hoisted (only the variable declaration is hoisted, 
      but the assignment happens at runtime). 

    ** Functions are hoisted first and then variables
    
    ** Functions and variable with SAME NAME, function is given more previlege 
        example -
            console.log(abc);
            var abc = 10;
            function abc() {
                console.log("i'm Function");
            }
            console.log(abc);


        During compilation phase ->
          function abc() {
            console.log("i'm Function");
          }
          var abc ; -> ** Here Function abc is not being overwritten because value is not assigned to abc
                          i.e since it's just a declaration, it doesn't override the function yet.

          console.log(abc);
          abc = 10;
          console.log(abc);

          Output - 
          function definition 
          10

    During compilation phase -
    Functions and variables declaration move top of their defining scopes
    variable creation takes place but initialization doesn't happens

    * when we declare a variable using var inside a function it is scoped there

    * SCOPES -
    var are function scoped and can be re-declared in the same scope
    whereas let is block scope , it cannot be re-declared
    function outer() {
    console.log(a); (1)
    var a = 10;
    var inner = function () {
        console.log(a); (2)
        a = 20;
        console.log(a); (3)
    };
    inner();
    console.log(a); (4)
    }

    outer();
    Output - 
        undefined
        10
        20
        20

8. Temporal Dead Zone - 

    Both let and const are hoisted but differs with var 
    let and const variable cannot be accessed before declaration and throws an REFERENCE ERROR,
    this is known as Temporal Dead Zone

9. Closures - 

    Closure occurs when one function is defined inside another function and the inner function has access 
    to outer function variable even after outer function has stopped executing.
    
        Example - 

            function Counter() {
            let count = 0;
            return {
                increaseMe: function () {
                count += 1;
                return count;
                },
                decreaseMe: function () {
                count -= 1;
                return count;
                },
            };
            }

            let myCounter = new Counter();
            console.log(myCounter.increaseMe());
            console.log(myCounter.decreaseMe());

    ** When you pass a function as a reference, the variables it uses depend on the lexical scope 
      where it was defined, not where it was called

        let name = "Global";

        function printName() {
            console.log(name);
        }

        function execute(callback) {
            let name = "Local";
        }

        execute(printName); // OUTPUT -> Global and not Local

10. Lexical Scoping - 

    When inner function has access to the variable of outer function is known as lexical scoping

11. Call, Apply and Bind - 

    Call - 
    it allows you to invoke a function with a specified this value and arguments provided individually
    example
    functionName.call(thisValue,args1,args2...)

    Apply - 
    it allows you to invoke a function with a specified this value and arguments provided as an Array
    example
    functionName.apply(thisValue,[args1,args2...])

    function functionName(arg1,arg2){
        console.log(arg1,arg2)
    }
    here arg1,arg2 will refer to arg1 passed in apply method

    Bind - 
    it returns a new function with a specified this value, It creates a new function which can be invoked later
    example
    const newFunction=functionName.bind(thisValue,args1,args2...)

    * It is used to re-use the methods created as an object property
    ** While destructuring an object, it looses its this binding (in STRICT MODE, in 
        Non - STRICT Mode this will be window object)
        example -
            const user = {
                name: "user123",
                greet: function () {
                    console.log("Hello, " + this.name);

                    const inner = () => {
                    console.log("Inside arrow: " + this.name);
                    };
                    
                    inner();
                }
                };

                const anotherGreet = user.greet;
            anotherGreet(); 
            // OUTPUT - 
                undefined 
                undefined 

    * This binding can again be attached using bind or re-attaching it
    
12. Arrow Functions vs Functions - 

    * THIS Keyword -
        
        For Normal Functions - 

            * This depends on how it is CALLED 
            * It looses its this binding when destructured
            * In non-strict mode: this is window (browser) or global (Node).
            * In strict mode: this is undefined.
                "use strict";
                console.log(this) // WINDOW OBJECT
                function test(){
                    console.log(this)
                }
                test() // UNDEFINED 
                const arrow = () => {
                console.log(this);
                };
                arrow(); // WINDOW OBJECT

        For Arrow Functions -

            * This depends on where it is CREATED i.e its lexical environment
            * It doesn't looses its this binding on destructuring ( because it is fixed at creation time )
            * Strict mode does NOT affects it.

        In Clases -

            * Everything is in STRICT MODE even if we dont define 'use strict'
            * If you use normal functions, this depends on how you call it.
            * If you use arrow functions, this will always refer to the class instance.

        example -
            const easyPeasyObject = {
                message: "Easy Right",
                showMessage: function () {
                console.log(this.message);
                },
            };

            // easyPeasyObject.showMessage();
            const fn = easyPeasyObject.showMessage;
            fn(); // OUTPUT - undefined

            class Challenger {
                constructor(message) {
                this.message = message;
                }

                showMessage = () => {
                console.log(this.message);
                };
            }

            const challenge = new Challenger("You WON");
            const fn1 = challenge.showMessage;
            fn1(); // OUTPUT - TypeError

    * Functions (Arrow & Normal Functions) are OBJECTS in Javascript 
        function(){}
        const func=()=>{}

        if(func || function(){}){
            // Always TRUE since Objects are Truthy values
        }

    * Arrow function doesn't have their own this value

    * They refer to their parents this value or Arrow function this refers to the Lexical scope in which 
      it has been defined

    * For Normal Functions this refers to the current context

    * Arrow functions dont have prototype property and returns undefined 
    
    * Using call, apply and bind, it will not change the this value inside Arrow function
        for example - 
            functionName.call({name:"ra"}) - here functionName will refer to {name:"ra"} object and not the global object

            let obj = {
              first: 1,
              last: 2,
              sumArrow: () => {
                console.log("Arrow This", this);
              },
              sumFunction: function() {
                console.log("Function This", this);
              },
            };
            obj.sumFunction() - THIS - Object itself
            obj.sumArrow() - THIS - Window Object

            class Calculator {
                constructor(a, b) {
                console.log("inside constructor", this);
                this.first = a;
                this.last = b;
                }
                sumArrow = () => {
                console.log("Arrow This", this);
                };

                sumFunction = function () {
                console.log("Function This", this);
                };
            }
            let cal1 = new Calculator(1, 2);
            cal1.sumFunction(); THIS - Object itself
            cal1.sumArrow(); THIS - Object itself since arrow function this is its current lexical scope

13. IIFE - Immediately invoked function expression

    (function definition)(function call as soon as it gets created)
    (function IIFE() {
    console.log("this is an IIFE")
    }) ();
    
    *For using two IIFE seperate it using semicolon

14. new keyword - 
    using new keyword to create objects, each call to the constructor object will create a new object 
    with its own memory allocation

15. Objects - 

    Different ways to create an Object in JS - 
    1. using literals 
            const obj2 = {
            name: "Minu",
            age: 27,
            logMe: function () {
                console.log(`Hey ${this.name} your age is ${this.age}`);
            },
            }
    2. using Object Constructor
    3. using function
    4. using class
    5. using JSON.parse(text in json format)
    *6. using Object.create( existingObject ) -> It creates new object using the existing objects as the prototype of
        the newly created object
    7. Object.assign(target,source) - it is also used copy source to target object
    
    ** 
    obj7 =  MyClassObject("Ravi", 26);
    obj7 = MyClassObject("Minu", 27);
    In this case it is overwritting the created object values
    here this will be window object but when using new keyword it refers to MyClassObject this value
    obj7 = new  MyClassObject("Ravi", 26);
    obj7 = new MyClassObject("Minu", 27);
    
    ** you cannot copy methods using JSON.parse
    
    Object.defineProperty - 

        It is a method that adds new properties to an Object or modifies existing one but with more
        control than just writing obj[key]=value

        syntax - Object.defineProperty(object, propertyName, descriptor)
        example -
            let user = {};
            Object.defineProperty(user, 'name', {
            value: 'Ravi',
            writable: false,     // can't change the value
            enumerable: true,    // shows up in loops
            configurable: false  // can't delete or reconfigure
            });

        * value	- The value of the property.

        * writable - Can the value be changed? (true/false)

        * enumerable - Determines if the property is visible during enumeration 
        (e.g., using for...in or Object.keys()).If enumerable: false, the property does not appear in 
        enumerations but can still be accessed directly.
        
        * configurable - Indicates whether the property can be deleted or reconfigured (i.e., its descriptors
        like writable, enumerable, or even value can be changed).If configurable: false, 
        you cannot: Delete the property. Change most of its descriptors (except writable).

    Object.freeze() vs Object.seal()

        *freeze() makes an Object immutable i.e no property can be added, removed, modified, but nested properties are 
        not freezed
        whereas seal() prevents from adding new properties and makes existing properties as non configurable i.e 
        using defineProperty you cannot modify that object but you can modify exisitng properties values
        (configurable-false, writable-true)
        
    Object.assign - 

        It is used to create shallow copy of Objects
        * spread operator also creates shallow copy of object

    Shallow Copy vs Deep Copy - 

        In shallow copy the immediate properties of an object are copied and not the NESTED properties,
        i.e it is done only at the FIRST level
        new object created through shallow copy shares references to the nested objects.
        spread operator, normal object assignment,Object.assign(), Object.create() all these
        creates shallow copy of the object

        whereas in deep copy all the properties of object along with its nested objects are copied,
        new object created using deep copy has new reference or entirely newly created object

        using JSON.parse(JSON.stringify(obj)) we can create a deep copy of an object

16. Loops & Map, Filter, Reduce - 
    
    map, filter, reduce methods returns new array and does not modifies the existing array whereas 
    forEach,for,forof,forin doesn't returns anything
    
    for of is used to iterate over iterable i.e Arrays

    Array.reduce(callbackFn,initialValue)
    Array.reduce(( accumulator , nextValue ), initialValue )
                filteredData.map((item) => item.amount)
                .reduce((accumulator, current) => accumulator + current, 0)
    * If initial value is not given in reduce method it takes first value as the accumulator value
    
17. SetTimeout & SetTimeInterval & ClearTimeout & ClearTimeInterval

    this concept in SetTimeout function

    *
    for (var i = 0; i < 10; i++) {
    setTimeout((i) => {
    console.log(`Executed after ${i} seconds`);
    }, i * 1000);
    }

    This happens because var is not block scope, it is hoisted to the function scope
    if we change var to let, let is block scope and creates lexical environment for each execution of if

    for (let i = 0; i < 10; i++) {
    setTimeout((i) => {
    console.log(`Executed after ${i} seconds`);
    }, i * 1000);
    }
    To replicate same using var keyword
    we can do this
    for (var i = 0; i < 10; i++) {
    function Execute(index) {
    setTimeout(() => {
      console.log(`Executed after ${index} seconds`);
    }, index * 1000);
     }
    Execute(i);
    }

18. Promises - 

    Promises are objects in Javascript which represent completion or failure of an asynchronous operation
    It has three states - 
    pending, fullfilled or rejected
    .then - fullfilled states
    .catch - rejected states
    .finally - gets executed everytime 
    
    const myPromise=new Promise((resolve,reject)=>{})

    * Conditionally resolve/reject a promise - (on a button click)
        myPromise=new Promise((resolve,reject)=>{
            document.getElementById("btn").addEventListener('click',function(){
                resolve("Promise has been resolved")
            })
        })
        
    * Create a promise in pending state -
        myPromise=new Promise((resolve,reject)=>{}) 
        When we are neither resolving or rejecting a promise , then it is created in PENDING state

    ** We can use AWAIT outside async function if script is of type MODULE

    Promise.all([]) - 

        Promise.all returns the value promises as an array of values when all promises are 
        settled , when any of the promise gets rejected it stops
        or we can say that it executes till first rejection
        * It works all at once i.e all promises start executing simultaneously
        * using map will also make concurrent requests, to resolve that use Promise.all

    Promise.any([]) - 

        It returns the value of first promise to be resolved
        If none of the promise gets resolved, it returns the rejected value of last promise

    Promise.allSettled -

        It returns the value of promises when all promises gets resolved

    Promise.resolve(value) & Promise.reject(value) - 
    
        It directly resolves or rejects the promise with the given value

    ***.then(res=>{return "value"}) -> Whatever is returned from .then() is wrapped as a fullfilled promise

19. Async await - 

    It is used to handle promises or asynchronous tasks in Javascript
    when await keyword is encountered, Javascript waits there and checks if any other tasks is there to finish
    or not
    Inside of async function works Synchronously
    Till the time ,execution of code is waiting at await keyword all other possible tasks which can be finished gets 
    executed
    *async function returns a promise by default

    const myPromise1 = new Promise((resolve, reject) => {
        if (true) {
        setTimeout(() => resolve("Promise 3"), 3000);
        } else {
            reject("The myPromise has been rejected");
            }
            });
    const myPromise2 = new Promise((resolve, reject) => {
        if (true) {
            resolve("Promise 4");
        } else {
            reject("The myPromise2 has been rejected");
        }
            });

    async function callPromise() {
        console.log("mypromise 1");
        const p1 = await myPromise1;
        console.log(p1)
        console.log("mypromise 2");
        const p2 = await myPromise2;
        console.log(p2)
        console.log("mypromise 3");
            }
    function logMe() {
        console.log('Hey i"m logginggg......');
        }

    console.log('Start')
    setTimeout(() => console.log("Waiting for 0 seconds", 0));
    setTimeout(() => {
        console.log("setTimeout function");
        }, 5000);
    logMe()
    callPromise();
    console.log('End')

    Output
    // Start
    // hey i"m logginggg......
    // mypromise 1
    // End
    // Waiting for 0 seconds
    // Promise 3
    // mypromise 2
    // Promsie 4
    // mypromise 3
    // setTimeout function

20. Fetch Api - 

    It is a promise based API whereas xmlhttpRequest is callback based API.

    fetch(url,options)
    options:{
        method:"GET/POST",
        headers:{
            "content-type":"application/json"
        },
        body: this must match headers content type JSON.stringify(data)
    }

21. Try-catch - 

    try{
        expression if throws any error goes to catch block
    }
    catch(error){
        console.log(error)
    }
    finally{
        gets executed everytime
    }

22. Callback function - 
    A function which gets executed after all the tasks which gets completed is called callback 
    example function(logData){
        some operations
        logData() // here logData is a callback function
    }

23. Higher Order Function - 

    A function which takes another function as a argument or  returns another function as an output is
    called a Higher order function
    examples - map,filter,reduce all are higher order functions

24. Callback hell - 

    When a callback is called inside another callback it is referred as callback hell i.e nesting of multiple
    of callbacks inside a function

25. OOPS - 

    Javascript implements 
    Encapsulation - example class
    inheritance - using Prototype
    Polymorphism - same function used in many forms
    Data Abstraction - JS doesnt have access modifiers like private,public,protected . So it is achieved using 
    Closures or WeakMap object

26. *Prototypal Inheritance - 

    * Prototype is a mechanism by which JavaScript objects inherit features from other objects

    * Every JavaScript object has an internal property called [[Prototype]] 
       (often accessed via the __proto__ property or indirectly through Object.getPrototypeOf())

    * This [[Prototype]] property links the object to another object, known as its prototype.

    * Prototype modifications (e.g., adding methods or properties) affect all instances dynamically, 
        even those created before the modification.
        Replacing the entire prototype (using Object.prototype = { logMe:function(){console.log(this)} }) 
        breaks the connection for existing instances, as they still refer to the original prototype object.

    * Object Literals ({}) always refer to Object.prototype as their prototype.

    * Objects created via a function constructor (new Function()) refer to Function.prototype as their 
      prototype.

    By default everything in Js points to an Object.
    We can add properties to prototype of an Object
    By default Js first searches for the property in Objects prototype, if it is not available it will search
    in its parents prototype and so on until the property is found, this is called prototypal based inheritance
    If not found it returns undefined.

    To get prototype of an object - 
    Object.getPrototypeOf(person1)
    Object.getPrototypeOf(person1,{'name'})

    To set prototype of an object - 

    Object.setPrototypeOf(person1,{
        prototype object
    })

27. BOM && DOM - 

    Browser Object Model -  It is an Object provided by the browser, examples window.open(),window.close(),
    window.scrollTo(),window.scrollBy, document etc

    Here the document object is known as the Document Object Model i.e DOM
    DOM is basically tree like structure or representation of HTML elements

    Node  vs Element -

        Every part of an HTML document i.e Elements , Texts , Comments are considered as a Node
        DOM is the tree like structure of Nodes
        In DOM Nodes can be of different types such as Element Node (1), Text Node (3), Comment Node(8)
        Each Node has a nodetype value
        The Document itself is a document node of type 9

        Whereas Element is an specific type of Node. It represents HTML Tags like div span a etc
        Every Element is a Node but every Node is not an Element

        example -
            <div>Hello <span>World</span></div>
            <div> → Element node
            "Hello " → Text node
            <span> → Element node
            "World" → Text node

    HTMLCollection vs NodeList

        An HTMLCollection is always a live collection. Example: If you add a <li>
        element to a list in the DOM, the list in the HTMLCollection will also change.
        A NodeList is most often a static collection. Example: If you add a <li>
        element to a list in the DOM, the list in NodeList will not change.
        The getElementsByClassName() and getElementsByTagName() methods return a live
        HTMLCollection.
        The getElementById() & querySelectorAll() method returns a static NodeList.
        The childNodes property returns a live NodeList
        HTMLCollection items can be accessed by their name, id, or index number.
        NodeList items can only be accessed by their index number. 

        document.getElementById - returns an Element Object
        document.getElementsByClassName - returns a HTMLCollection
        document.querySelector - returns an Element Object
        document.querySelectorAll - returns a NodeList
        document.getElementByTagName - returns a HTMLCollection
            
            example -
                let ul=document.getElementsByTagName('ul')
                let li=document.querySelectorAll('li')
                console.log("HTMLCollection - LiveList",ul[0].children)
                console.log("NodeList - Static List",li)

                // add an li to ul

                let element=document.createElement('li')
                element.innerText="This is added using JS"
                ul[0].append(element)
                console.log("HTMLCollection - LiveList",ul[0].children) // Logs the updated HTMLCollection 
                console.log("NodeList - Static List",li) // Logs the Static NodeList before updation
                console.log(document.querySelectorAll('li')) // Logs the updated Nodelist 

    *NodeList can be STATIC or LIVE (dynamic) depending upon how it is obtained

        example -  
            document.querySelectorAll('li') - gives static NodeList 
            document.getElementsByTagName('ul')[0].childNodes - gives Live NodeList

        Static NodeList doesnot reflect DOM changes
        Dynamic NodeList refeclects DOM Changes

    *children vs childNodes -

        Children gives Element nodes of the parent whereas childNodes gives the all the Nodes (like 
        text node, Comment Node, Element Node) of the parent
        
        * Both children and childNodes gives live lists i.e children -> Live HTML Collection 
          & childNodes -> Live NodeList

    append vs appendChild - 

        append - it can accept,single & multiple Node values , strings (DOM Strings) as an input
        It doesn't have a return value
        example document.getElementsByClassName.append(div, 'div')

        appendChild - it accepts only Element or Node and adds to the end of NodeList
        It returns the appended Node object
        example document.getElementsByClassName.appendChild('div') throws an error

        ** HTMLCollection[0].childNodes gives the Node object and we can perform append or appendChild on
            HTMLCollection[0] and not on HTMLCollection

    innerText vs textContent vs innerHtml - 

        innerText - It is used to get or set the text content of an element considering the CSS
        and it doesnt includes hidden text of an HTML element 
        
        textContent - It is used to set or get the text content along with text nodes and white content
        of an element without considering the CSS

        innerHtml - It is used to set or get the Html content of an element
        *using innerHtml (XSS) Cross site scripting attacks are possible so it is not recommended
    
    *remove vs removeChild - 

        remove is a method directly available on DOM elements whereas removeChild is a method which is
        available on PARENT'S NODE and used to remove child elements    

    *getAttribute vs setAttribute -
        <div  data-id="123">This is a DIV </div>

        To get/set the attribute data-id
        document.getElementById("div").getAttribute("data-id")
        document.getElementById("div").setAttribute("data-id","321")

    **document.getElementById("id").style.display="block" -> sets the INLINE CSS and not the external css
    
    classList methods -

        It is a property of DOM Element which returns the elements classes

        classList.add(className) - Adds a specified class to the Element
        classList.remove(className) - Removes a specified class to the Element
        classList.toggle(className) - Toggles a specified class to the Element if it is not available
        classList.toggle(className, true / false) - Ensures it's added

    Data Attributes -

        It is an way to store extra information in an HTML, It does affects how the page looks but helps 
        in JS logics

        * They are custom attributes that start with data- and can be added to any HTML element
          example -
                    <div id="user" data-user-id="123" data-role="admin">Ravi</div>
                    
                    Here data-user-id is a data attribute

            To access data attribute -
                .dataset is used to get the attributes
                document.getElementById('user').dataset.userId
                document.getElementById('user').dataset.role

    Offset vs getBoundingClientRect vs Client Properties -

        Offset Properties
            offsetTop / offsetLeft:
            ➤ Distance from the top/left of offset parent
            ➤ Does NOT include margins
            ➤ Good for positioning inside containers

        clientX / clientY
            Mouse event properties
            ➤ Coordinates of the mouse pointer relative to the VIEWPORT
            ➤ Useful in events like mousemove, click
            ➤ clientX = horizontal position, clientY = vertical position

        getBoundingClientRect()
            Returns position + size of an element relative to the VIEWPORT
                {
                    top: 120,      // distance from top of viewport
                    left: 240,     // distance from left of viewport
                    width: 200,
                    height: 50,
                    bottom: 170,   // top + height
                    right: 440     // left + width
                }

28. Event bubbling vs Event Capturing - 

    By default an event follows bubbling mode.
    In bubbling mode event propagates from child to parents whereas in event capturing mode event propagates 
    from Parent to child

    * element.addEventListener('eventName',function,false) BUBBLING Mode
    * element.addEventListener('eventName',function,true) CAPTURING Mode
    *We can stop propagation of bubbling events using event.stopPropagation()

29. Event Simulation & Event Delegation - 

    Calling an event from Javascript which is not depending upon user action is known as event simulation 
    example  - addEventListener.click(), form.submit() etc

    Instead of applying event to each child we can apply event to the parent and have the same outcome is
    termed as event delegation
    example -
        document.getElementsByTagName("ul")[0].addEventListener(
            "click",
            function (event) {
            console.log("clicked UL",event);
            }
        );

30. CallStack vs Event Loop vs Callback Queue vs Execution Context - 

    CallStack(LIFO) - Whenever a function is called in JS, a new execution context is created and then the function 
    moves to the CallStack, After completion of that function it is popped out of the CallStack

    Web API's - 
    DOM Manipulation, Promises, Fetch API, events , xmlhttpRequest etc all are handled by web api's which is 
    generally the browser in front end case
    All these functions move to the web apis and then to the callback queue(FIFO)

    Event Loop - 
    Event loop keeps a check on CallStack and Callback Queue
    Whenever CallStack is empty, a new function from callback queue is pushed to the CallStack and this circle goes on
    goes on until the callback queue is not cleared

    *MicroTasks vs MacroTasks - 
     MicroTasks - Promises, fetch api
     MacroTasks - setTimeout etc
     MicroTasks > MacroTasks

    Execution Context - It holds information about the environment in which Javascript is being executed
    During the execution , a context is created everytime
    Firstly variable creation phase takes place and then value assignment takes place

31. Map & Set - 

    Map are objects in JavaScript which stores key-values pairs
    *Keys can be of any type unless Objects where keys are of type string
    let myMap=new Map()
    myMap.set(key,value)
    myMap.get(key)
    myMap.keys()
    myMap.values()
    myMap.entries()
    *let recipeMap = new Map([
        ['cucumber', 500],
        ['tomatoes', 350],
        ['onion',    50]
        ]);

    *Set are also objects in JavaScript that store only UNIQUE values unlike Map which stores key-values
    let mySet=new Map()
    mySet.add(key,value)
    mySet.delete(key)
    mySet.keys()
    mySet.values()
    mySet.entries()

32. Proxy - 
    Proxy in JavaScript is an object which acts as a wrapper for plain objects.
    It helps to create custom behavior for objects.

    *const proxy=new Proxy(targetObject, handler object)
     *here target object is the object which you want to proxy
     *handler is an object with get,set,deleteProperty,has,apply,construct methods which helps 
     to intercept the object

     example - 
            const target = {
        message1: "hello",
        message2: "world"
        };
        const handler = {
        get: function(target, property) {
            if (property === 'message2') {
            return 'proxy';
            }
            return target[property];
        }
        };
        const proxy = new Proxy(target, handler);
        console.log(proxy.message1); // hello
        console.log(proxy.message2); // proxy

33. Currying -

    It is a technique in JavaScript using which function with multiple arguments are converted into 
    sequence of functions each taking a single arguments
    example ->
            function add(a, b) {
                return a + b;
                }

        function curryingAdd(a) {
            return function (b) {
                return a + b;
            };
            }
            console.log(curryingAdd(5)(6));

34. Throttling -

    It ensures that a given function in called at most once in given interval of time even if it is called
    multiple times. It is used to control the rate of execution
    example -
    function throttle(func, delay) {
        let lastTime = 0;

        return function (...args) {
            let now = Date.now();
            if (now - lastTime >= delay) {
            lastTime = now;
            func(...args);
            }
        };
        }

        function logMe() {
        console.log("Logging");
        }
        let t = throttle(logMe, 5000);
        document.getElementById("throttle").addEventListener("click", t);

35. Debouncing -

    It ensures a function in called after specified amount of time has passed i.e It delays invocation

    function debounce(func, delay) {
        let timer = 0;
        return function () {
            clearTimeout(timer);
            timer = setTimeout(func, delay);
        };
        }

        function logMe() {
        console.log("Logging");
        }
        document.getElementById("debounce").addEventListener("click", debounce(logMe,1000));

36. Polyfill -

37. Rest, Spread Operators & Default parameter value -

38. Generator Functions -

    Generator are special functions in JavaScript that pause execution, yield value and resume 
    execution later.
    *generator functions can delegate to another generators using yield*
    *generator functions are iterable by default and forof loop can be used
    example -
    function* generator() {
        yield 1;
        yield 2;
        yield 3;
        }
        let gen = generator();
        console.log(gen.next());
        console.log(gen.next());
        console.log(gen.next());
        console.log(gen.next());

        *Using generator functions for iterating over an object
            function* iterateGenerator(object) {
            for (const key in object) {
                if (Object.prototype.hasOwnProperty.call(object, key)) {
                yield [key, obj[key]];
                }
            }
            }

            for (const [key, value] of iterateGenerator(obj)) {
            console.log(key, value);
            }

39. Date Object -

40. Regex Expressions -

    Using literal syntax -

        const pattern1=/hello/gi

    Using Constructor syntax -

        const pattern2= new RegExp(pattern,flags)
        const regExpEmail= new RegExp("abc","gi")

41. String Manipulation -

42. Value vs DefaultValue vs Selected attribute in Select in React/JS -

        * value make the component a Controlled component
          defaultValue makes it uncontrolled component

        * When both value and defaultValue are specified, React prioritizes value and ignores defaultValue.

        * The defaultValue only sets the initial value of the <select>, but subsequent changes to Select 
          will not update the <select> value.Wheareas value will reflect the subsequent changes provided
          it is being set using an onchange

        * Selected attribute works for the initial render only in both React & JS, after that it shows
            value based on value porperty
            Even if Selected={stateValueInReact} even when state changes and component re-renders, here React
            ignores the Selected property while re-rendering

43. Object.toString() -

    The Object.prototype.toString method uses this [[Class]] property to generate the type string.
    The format returned is [object <Type>], where <Type> is the specific type derived from [[Class]]
    It returns by default - [object <Type>]
    Where 1st object indicates it is an OBJECT and 2nd object is its internal ClassName

    *** Object.prototype.toString(value) - here this refers to the Object.prototype and so it gives output
        as object Object
        To check type of specific value use Object.prototype.toString.call(value) , which returns object Type

    * By default it works for all data types except null and undefined
      for null and undefined it thrwos an error
        let value=null or undefined
        value.toString() - throws error

    * null and undefined can be stored using String wrapper class
        a=String(undefined)
        a.toString() - > "undefined"
    *For Arrays - It return string with elements joined using ','
    *For Functions - It return string format of function definition
    *For Date - It returs date in human readable format

44. JSON.stringify() limitations -

        * JSON.stringify() If keys are same but differs in order then stringify cannot be used to compare 
            two objects.
            
        * JSON.stringify() ignores properties whose VALUES are functions, undefined, or symbol
            let obj = {
                a: 10,
                b: undefined,
                c: function() { return 20; },
                d: Symbol("test")
                };
                console.log(JSON.stringify(obj)); // {"a":10}

        * Non-enumerable properties (properties that are not included in Object.keys) are not included 
            in the JSON string
            let obj = {};
            Object.defineProperty(obj, 'hidden', { value: 'secret', enumerable: false });
            obj.visible = 'visible';
            console.log(JSON.stringify(obj)); // {"visible":"visible"}
            we can check all the properties using Object.getOwnPropertyDescriptors(Obj)

        * The prototype chain is ignored during serialization, so inherited properties are not included.
            function Person(name) {
                this.name = name;
                }
                Person.prototype.age = 30;

                let person = new Person("John");
                console.log(JSON.stringify(person)); // {"name":"John"}

        * While undefined is ignored in objects, it is converted to null in arrays.
            let arr = [1, undefined, 3];
            console.log(JSON.stringify(arr)); // [1,null,3]

        * If the object being stringified contains circular references (where a property refers back 
          to the object itself), JSON.stringify() will throw a TypeError.
          let obj = {};
            obj.self = obj;
            JSON.stringify(obj); // TypeError: Converting circular structure to JSON

        * JSON.stringify(object,replacer,space) -

          replacer can be a function or array of keys
          console.log(JSON.stringify(obj, ["name", "value"])); - It will convert into JSON with given keys only
          We can give custom replacer function which will replace as per our needs

45. Html events vs Javacsript events -

    Javacsript events - 
    Javacsript events are actions that happens in the browser when User interacts like clicking,
    dragging, key press etc or when the page Loads
    we can listen to these events using addEventListener(eventName,callbackFn,propagationType=false(default))

    HTML events -
    These are the events which are directly binded with the html element as attributes to provide 
    more flexibility, but behind the scene they are an Javacsript event only

    Available on both -
    onclick, onMouseover etc

    Available only with JS -
    scroll event,focus event, blur event, load event, DOMContentLoaded event etc

46. Session storage, Local storage vs cookies -

    Session storage - 

        It is web storage API that stores data for the duration of browser session (TAB specific), once
        the tab is closed the data is lost
        Maximum storage ~ 5MB
        It is only accessible in the client side
    
    Local storage -

        It is similar to session storage but stores data even after the brower is closed.
        It is shared accross all tabs/windows of same origin
        Data persists until explicitly cleared by the user
        Maximum storage ~ 5MB
    
    Cookies - 

        Cookies are small pieces of data stored on the client side i.e browser by the server and 
        sent back to the server with every request
        Maximum storage ~ 4KB
        It can be set to expire at a given time (Expires or Max-Age)
        *It is accessible by both client side and server side
        Use case includes - Authentication of JWT's token
        Session cookies (default) expire when the browser is closed
        
        *document.cookie="username=Ravi; Max-Age=3600(in seconds); Path=/; Secure; HttpOnly"
        *console.log(document.cookie)

47. type="text/javascript" vs type="module" -

    type="module" -

        By using type="module" in script tag tells the browser to treat script as Javascript modules
        This allows us to use the ES6 module features such as import and export.
        Script with type="module" are executed in STRICT mode and variables and functions have module 
        level scoping

        *With type="module" scripts are deferred, meaning the script is executed only after HTML parsing
         is completed similar to defer attribute

        
    type="text/javascript" -

        It is used for standard JavaScript not generally in STRICT mode
        Cannot use import export here

48. WeakMap -

    It is a special type of Map is javascript introduced in ES6 that holds weak references to its keys.
    It is similar to Map but can only have OBJECTS OR FUNCTIONS as its keys

    * Weak keys are held WEAKLY means if there are no references to the keys then they are
      garbage collected automatically by the js engine

    * Keys must be OBJECTS OR FUNCTIONS , primitive values such as string, numbers etc cannot be used
    
    * They are not enumerable
    
        let myweakMap=new WeakMap()
        let myobj={
            name:'ravi'
        }
        myweakMap.set(myobj,"ravi")
        myobj=null
        console.log(myweakMap)

49. FileReader in JS -

50. Symbols -

    It is a primitive data type in Javascript, generally used as keys in objects to differentiate two
    object keys

    *Symbols are not enumerable i.e we cannot run loops on it

    * Symbol("value") always creates a NEW symbol
      let sm1 = Symbol("abc")
      let sm2 = Symbol("abc")
      sm1 === sm2 --> false

    * Symbol.for("") creates symbol GLOBALLY , if it exists already then NEW symbol is not created 
      rather same is returned from the global pool

      let sym1=Symbol.for('abc')
      let sym2=Symbol.for('abc')
      sm1 === sm2 --> true

51. isNaN vs Number.isNaN() -

    isNaN first converts the value to number and checks that the value is NaN  
    examples -
        isNaN(123) -> false
        isNaN("123") -> false
        isNaN("ravi") -> true
        isNaN(NaN) -> true
        isNaN(undefined) -> true

    Whereas Numebr.isNaN() checks whether the given value is NaN or not
    examples -
        Number.isNaN(123) -> false
        Number.isNaN("123") -> false
        Number.isNaN("ravi") -> false
        Number.isNaN(NaN) -> true
        Number.isNaN(undefined) -> false

52. import vs dynamic import() -

    import - 

        It is preparsed at COMPILE TIME and enables TREE Shaking by default
    
    import() -

        Used for conditionally loading the content 
        It is parsed at RUNTIME
        It returns a Promise and error handling must be done properly

53. JIT ( Just in Time Compiler ) -

54. Equality Check ( == vs === ) -

    * Non-primitive data types are always compared using their references and not by their values
    
    * === checks the TYPE and VALUE if primitive data type & TYPE and REFERENCE if non - primitive 
      data type
      examples - 
        console.log("abc" - "xyz"); // NaN
        console.log(0 <= 1); // true
        console.log(NaN - NaN); // NaN
        console.log(null === null); // true
        console.log({} == {}); // false
        console.log([] == {}); // false
        console.log({} === {}); // true
        console.log([] === {}); // false

        const obj1 = { a: 1 };
        const obj2 = { a: 1 };
        const obj3 = obj1;

        console.log(obj1 === obj2); // false ❌ (same structure but different reference)
        console.log(obj1 === obj3); // true ✅ (same reference)

55. Splice vs Slice -

    Splice - Modifies the original array

        array.splice(startIndex, deleteCount, item1, item2, ...)
        example -
            let arr = [1, 2, 99, 100, 5];
            arr.splice(2, 2, 3, 4);
            console.log(arr); // [1, 2, 3, 4, 5]

    Slice - Does'nt modifies the original array

        array.slice(startIndex, endIndex) // endIndex is non-inclusive
        example -
            let arr = [1, 2, 3, 4, 5];
            let sliced = arr.slice(1, 4);
            console.log(sliced); // [2, 3, 4]
            console.log(arr);    // [1, 2, 3, 4, 5] → unchanged

56. Accessible Rich Internet Applications( ARIA ) - 

    It is a powerful tool for enhancing accessibility in web applications.It ensures that all users
    including those with visual or cognitive impairements can understand and interact with the website

    ARIA defines three types of attributes:
        Roles
            Describe what an element is.
            Example: role="button", role="dialog", role="tab".
            Useful when you’re using a <div> or <span> to build a component that visually behaves like a native element (e.g., a button).

        States  
            Describe the current condition of an element.
            Example: aria-expanded="true" or aria-checked="false".

        Properties
        Define characteristics of elements that are consistent over time.
        Example: aria-labelledby, aria-describedby.

57. 'use strict' -

    * Strict mode is not enabled by default in Javacsript, it needs to be enabled using 'use strict'

    * Strict mode helps to catch common errors while developing and it doesn't allows for -
        * creating variable without let var or const
        * Makes this undefined in functions (instead of global object)
        * Disallows duplicate parameter names

    * By default for type='module' strict mode is enabled

58. Workers
59. Progressive Web Apps
60. Form events

61. Performance optimization techniques ( HTML CSS Javacsript Application ) -

    1. Minimize and Optimize Assets -

        Minify HTML/CSS/JS using tools like Minifier to remove white spaces and Comments

    2. Image optimization -

        Compress images using online tools such as TinyPNG to compress the images
        Use modern formats such as WebP or avif instead of JPG/PNG
    
    3. Lazy Load -

        Lazy load script and images

        <img src="./image.webp" alt="image" loading="lazy" />
        * By deafult images are eager loaded

    4. Use CDN -

        To serve static assets like images, CSS, JS use CDN links such as Cloudfare, AWS CDN
    
    5. Use Efficient Fonts -

        Use Efficient fonts with latest standards such as WOFF2
    
    * To ananlyze all the optimization & improvements in Chrome's Dev tool we can use -
      
        1. LIGHTHOUSE TAB - For automated result of key metrics such as Best Practices, SEO, Performance
        2. PERFORMANCE TAB - For Manual results

62. class -

    * It is a blueprint for creating objects

    * Class is like a template using which we create objects

    * Everything inside class is in STRICT MODE even if we dont specify it

    * We can declare private variables using #
        class Laptop {
            #brand;
            constructor(brand) {
                this.#brand = brand;
                }
            }

            const myLaptop = new Laptop("Dell");

    * static keyword is used to declare a variable or method as static, it is accessed without 
      creating Object and directly using the class
        class MathUtil {
            static add(a, b) {
                return a + b;
            }
        }
        console.log(MathUtil.add(2,3)); // 5


    * Extends keyword is used for inheritance     

    * super() is used to call constructor of parent class

    * get set are used to define getters and setters

        class Laptop {
        #brand;
        
        constructor(brand) {
            this.#brand = brand;
        }

        // Getter
        get brandName() {
            return this.#brand;
        }

        // Setter
        set brandName(newBrand) {
            this.#brand = newBrand;
        }
        }

        const myLaptop = new Laptop("Dell");

        console.log(myLaptop.brandName); // 👉 "Dell" (getter used)

        myLaptop.brandName = "HP";       // 👉 (setter used)
        console.log(myLaptop.brandName); // 👉 "HP"

    example -

        class Product {
        constructor(name, price) {
            this.name = name;
            this.price = price;
        }

        display() {
            console.log(`${this.name} costs $${this.price}`);
        }
        }

        class Electronic extends Product { // INHERITANCE
        constructor(name, price, brand) {
            super(name, price);
            this.brand = brand;
        }

        display() {
            console.log(`${this.brand} ${this.name} costs $${this.price}`);
        }
        }

        const laptop = new Electronic("Laptop", 1500, "Dell");
        laptop.display(); // Dell Laptop costs $1500
